<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++关键字学习(一)</title>
      <link href="/2019/09/27/cpluspluskey/"/>
      <url>/2019/09/27/cpluspluskey/</url>
      
        <content type="html"><![CDATA[<p>#alignas关键字<br>##注释</p><p><strong>C++中用来设置结构体内部的对齐方式常常与alignof关键字连用，这个是用来查看对其的字节数。</strong></p><p>##示例代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct alignas(8) S &#123;&#125;;</span><br><span class="line">struct alignas(1) U &#123;S s;&#125;;</span><br><span class="line">struct Foo&#123;</span><br><span class="line"> int i;</span><br><span class="line"> float f;</span><br><span class="line"> char c;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">struct Empty&#123;&#125;;</span><br><span class="line">struct alignas (64) Empty64&#123;&#125;;</span><br><span class="line">struct alignas (1) Double &#123;</span><br><span class="line"></span><br><span class="line">double d;</span><br><span class="line">&#125;;</span><br><span class="line">struct Obj&#123;</span><br><span class="line"> char a;</span><br><span class="line"> int b;</span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc , char** argv)&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; alignof(char) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; alignof(int* ) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; alignof(Foo) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; alignof(Empty) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; alignof(Empty64) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; alignof(Obj) &lt;&lt; endl;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#asm关键字</p><p>##注释：用来嵌入汇编语言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">asm(&quot;movq $60, %rax\n\t&quot;</span><br><span class="line">   &quot;movq $2, %rdi\n\t&quot;</span><br><span class="line">   &quot;syscall&quot;    </span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#简单介绍关键字auto(以后会有详细的介绍)</p><span id="more"></span><p>##注释：<br><strong>自动类型的推导，根据值直接推出类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int aa = 1+2;</span><br><span class="line">auto a = 1 +1;</span><br><span class="line">cout &lt;&lt; &quot;type of a&quot; &lt;&lt;typeid(a).name() &lt;&lt; endl;</span><br><span class="line">auto b = add(1,1.2);</span><br><span class="line">cout &lt;&lt; &quot;type of a&quot; &lt;&lt;typeid(b).name() &lt;&lt; endl;</span><br><span class="line">auto c = &#123;1,2&#125;;</span><br><span class="line">cout &lt;&lt; &quot;type of a&quot; &lt;&lt;typeid(c).name() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#bool关键字<br>##注释：<br><strong>在此时Linux表现一个字节且转为char后，赋值-1后为255，且依然判定为true</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void testBool()&#123;</span><br><span class="line"> auto a = true;</span><br><span class="line"> auto b = false;</span><br><span class="line"> *(reinterpret_cast&lt;char*&gt;(&amp;a)) = -1;</span><br><span class="line"> cout &lt;&lt; a &lt;&lt;&quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"> if(a==true)&#123;   //最好不要这样写 而是改成if(a)</span><br><span class="line">  cout &lt;&lt; &quot;i`m true&quot; &lt;&lt;endl;</span><br><span class="line"> &#125;else if(a==false)&#123;</span><br><span class="line">  cout &lt;&lt; &quot;i`m false&quot; &lt;&lt; endl;</span><br><span class="line"> &#125;else&#123;</span><br><span class="line">  cout &lt;&lt; &quot;what??&quot; &lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#char关键字</p><p>##注意：</p><p><strong>在Linux下char是unsigned char 而在windows下则是signed char</strong></p><p>#constexpr关键字用法<br>##注释：<br>###这个关键字主要是用来使函数在编译器就能得到返回值，并且用这个返回值进行替换来优化函数，正如例子中，可以用来当成一个数值来定义数组之类的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int fact(int n)&#123;</span><br><span class="line">return n &lt; 1?1:(n * fact(n-1));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">constexpr int factorial(int n)&#123;</span><br><span class="line"> return n &lt;=1? 1:(n * factorial(n-1));</span><br><span class="line">&#125;</span><br><span class="line">template&lt;int N&gt;</span><br><span class="line">struct NN&#123;</span><br><span class="line"> void print()&#123;cout &lt;&lt; N &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc , char** argv)&#123;</span><br><span class="line">       auto aa = fact(4);</span><br><span class="line">       auto bb = factorial(6);</span><br><span class="line">       char group[factorial(6)];</span><br><span class="line">       NN&lt;factorial(8)&gt; nn ;</span><br><span class="line">       nn.print();</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++语法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv踩坑之保存摄像头录像</title>
      <link href="/2019/08/11/opencv-01/"/>
      <url>/2019/08/11/opencv-01/</url>
      
        <content type="html"><![CDATA[<p>#背景介绍<br><em>由于项目要求实现一个视频聊天功能的软件，实现手机端到PC端，手机和手机端视频聊天，甚至包含屏幕分享功能，查阅了大量资料，鉴于对C++情有独钟，故开始了QT库的学习使用，利用其优良的跨平台特性。但是尝试了各种第三方库，似乎都不支持QT,无奈只能QT和web混合开发，但是奈何其兼容性并不好，于是乎选择自己造轮子，选择了强大的opencv库，巴拉巴拉开始安装，之前界面32位项目，但是安装opencv都是64位的，只能下载opencv源码自己编译成32位的，…… ……此处省略安装时反复跳坑填坑过程……，最后安装好了。</em><br>##获取摄像头并保存本地视频</p><p><strong>opencv其实是一个图像处理库，多用于人工智能的人脸识别，视频追踪等等。原理很简单，获取摄像头的图像，使用opencv里面的Mat来存储，然后把图像一张一张的显示在窗口上，然后再保存在本地，出错了，开始百度，谷歌，反复试验，经过漫长的一天，终于问题解决了。上代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\#include&lt;iostream&gt;  </span><br><span class="line">\#include&lt;opencv2/opencv.hpp&gt;  </span><br><span class="line">using namespace cv;  </span><br><span class="line">using namespace std;  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">Mat in_frame, out_frame;  </span><br><span class="line">const char win1[] = &quot;Grabbing...&quot;, win2[] = &quot;Recording...&quot;;  </span><br><span class="line">double fps = 30;//每秒的帧数  </span><br><span class="line">char file_out[] = &quot;E://recorded.avi&quot;;  </span><br><span class="line"></span><br><span class="line">VideoCapture inVid(0); //打开默认摄像机  </span><br><span class="line">if (!inVid.isOpened()) &#123; //检查错误</span><br><span class="line">cout &lt;&lt; &quot;Error! Camera not ready...\n&quot;;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">//获取输入视频的宽度和高度</span><br><span class="line">int width = (int)inVid.get(CAP_PROP_FRAME_WIDTH);</span><br><span class="line">int height = (int)inVid.get(CAP_PROP_FRAME_HEIGHT);</span><br><span class="line">VideoWriter recVid(file_out, VideoWriter::fourcc(&#x27;M&#x27;, &#x27;J&#x27;, &#x27;P&#x27;, &#x27;G&#x27;), 24, Size(width, height),true);</span><br><span class="line"></span><br><span class="line">//为原始视频和最终视频创建两个窗口</span><br><span class="line">namedWindow(win1);</span><br><span class="line">//namedWindow(win2);</span><br><span class="line">while (true) &#123;</span><br><span class="line">//从摄像机读取帧（抓取并解码）</span><br><span class="line"></span><br><span class="line">inVid &gt;&gt; in_frame;</span><br><span class="line">if (in_frame.empty())</span><br><span class="line">break;</span><br><span class="line">//将帧转换为灰度</span><br><span class="line">cvtColor(in_frame, out_frame, COLOR_BGR2GRAY);</span><br><span class="line">//将幀写入视频文件（编码并保存）</span><br><span class="line">recVid.write(in_frame);</span><br><span class="line">imshow(win1, in_frame);// 在窗口中显示帧</span><br><span class="line">//imshow(win2, out_frame); // 在窗口中显示帧</span><br><span class="line">if (waitKey(1000 / fps) &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">recVid.release();</span><br><span class="line">inVid.release(); // 关闭摄像机</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##总结原因<br><em>经过我一天的反复查阅，总结以下导致视频保存错误或者保存出的视频0kb或6kb，并且不能打开，显示格式错误或已经损坏错的原因:</em><br>###保存错误<br>    1.VideoWriter的构造函数第二个传参格式不对（通用格式为VideoWriter::fourcc(‘M’, ‘J’, ‘P’, ‘G’)），如果不行，可以尝试换其他参数试试</p><pre><code>2.打开摄像头失败，保存为空帧 （加上以下参数即可）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (in_frame.empty())</span><br><span class="line">break;</span><br></pre></td></tr></table></figure></code></pre><p>###保存为0kb或6kb<br>    1.未释放直接退出(加上以下代码)<br>    <code>recVid.release();</code></p><pre><code>2.格式不匹配(同第一个)3.这也是我犯的错误，就是到的帧和保存的帧填写的不一样导致的（在recVid.write(Mat保存的图像);）</code></pre>]]></content>
      
      
      <categories>
          
          <category> opencv踩坑系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
